---
layout: post
title: "Walking through the Royal Road"
date: 2023-07-13
tags: [x86, Shellcode, Exploitation, Malware Analysis] 
description: The post put a spotlight on the malicious RTF generated by the famous Royal Road weaponizer. 
---


# Introduction

Recently, numerous malicious RTF files generated by the Royal Road \_\_RTF weaponizer tool\_\_, are spotted in the wild to deliver attacks attributed to China State-Sponsored actors. So I decided through this post to analyze one of the files used in [Cyber Espionage on Tibetian Citizens](https://oviche.github.io/2023/01/Cyber-espionage-on-Tibetian-citizens/) to explain how to identify the attached exploit and spotlight some shellcode features.

# Overview

The first view of the RTF file shows the following two embedded objects: 
 
 - **ghb4nrwmp.wmf**
 - **Equation.2\x00\x124Vx\x90\x124VxvT2**.

![img]({{ '/assets/images/RoyalRoad/rtf1.png' | relative_url }}){: .center-image }*(**RTF document's embedded objects**)*

When the file is opened, the process **EQNEDT32.exe** gets executed and spawns another **EQNEDT32.exe** process. Then, the child **EQNEDT32.exe** process launches a subprocess **rundll32.exe**.

![img]({{ '/assets/images/RoyalRoad/rtf2.png' | relative_url }}){: .center-image }*(**The process tree when opening the RTF file**)*

The previous process tree can indicate that the file contains an exploit that targets the **EQNEDT32.exe**. This executable represents the **equation editor** of **Microsoft Office** that is responsible for interpreting the embedded equations inside the document files.

Probably the exploit will be embedded in the equation object which is called **Equation.2\x00\x124Vx\x90\x124VxvT2**.

# Setup a debugging environment

Debugging the **EQNEDT32.exe** process, will help us later to identify the **common vulnerabilities and exposures (CVE)** that the exploit is targetting and its contents' bytes.

This can be achieved by taking advantage of the [**Image File Execution Options (IFEO)**](https://www.malwarebytes.com/blog/news/2015/12/an-introduction-to-image-file-execution-options) feature will allow the debugger to attach the process **EQNEDT32.exe** as soon as it starts.

![img]({{ '/assets/images/RoyalRoad/rtf3.png' | relative_url }}){: .center-image }*(**Creating key for EQNEDT32 process under IFEO in registry**)*

# Determining the targetted CVE

My approach for identifying the targetted **CVE** will depend on the vulnerable function address and the RTF structure field that contains the exploit bytes, as explained below.

## Finding the vulnerable function
  
  Usually, there are the following two main ways in which the exploits use to execute unintended code after hijacking the execution:    
  
   - Using **NX memory** regions to execute shellcode which works when **Data Execution Prevention (DEP)** mitigation is off.
   - Using **Return oriented programming (ROP)** to bypass DEP mitigation by executing hosen machine instruction sequences from executable memory sections.

  Firstly, I assumed that the first technique that executes the shellcode in NX memory regions is used. Therefore, to identify the start address of the shellcode, I will enforce DEP mitigation for all Windows processes that will cause an exception when NX memory gets executed. 

   ![img]({{ '/assets/images/RoyalRoad/rtf4.png' | relative_url }}){: .center-image }*(**Turning on DEP mitigation for all Windows processes**)*


  Now by opening the RTF file, the debugger gets attached to the **EQNEDT32.exe** and then continues the execution till an exception is triggered. The address that causes the exception is pointing to the start of the shellcode.

  In the below screenshot, the address **0058b63a** is the start of the shellcode and is located on the heap memory.

   ![img]({{ '/assets/images/RoyalRoad/rtf5.png' | relative_url }}){: .center-image }*(**The starting address of the shellcode**)*

 Note that the **EBP** register holds a garbage value which indicates the occurrence of stack overflow that corrupts the saved frame pointer of the caller function.

   ![img]({{ '/assets/images/RoyalRoad/rtf6.png' | relative_url }}){: .center-image }*(**The corrupted EBP register**)*

So by looking at the stack, we can see the exploit bytes that are used to overflow the stack and control the return address. 

Also, because the return address of the vulnerable function is overwritten, the only thing that can be found on the stack is the return address for the caller function of the vulnerable function as appear below. 

   ![img]({{ '/assets/images/RoyalRoad/rtf7.png' | relative_url }}){: .center-image }*(**The state of the stack after the overflow**)*

By following the return address for the caller function of the vulnerable function in the disassembly, we can find the function at address **43a78f** is the caller of the vulnerable function.

  ![img]({{ '/assets/images/RoyalRoad/rtf8.png' | relative_url }}){: .center-image }*(**Finding the caller of the vulnerable function**)*


 
  
  



