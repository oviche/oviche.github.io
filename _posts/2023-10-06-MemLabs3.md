---
layout: post
title: "MemLabs: Lab3 Writeup"
date: 2023-10-06
tags: [Memory Forensics] 
description: The post shows the steps for finding the flags for the third challenge of MemLabs.
---

# Introduction

Last time, I posted a solution that shows how I approached the [second lab](https://oviche.github.io/2023/10/MemLabs2/) of [MemLabs](https://github.com/stuxnet999/MemLabs/tree/master) challenges. This post continues to show how I got the flags for the third lab of MemLabs, called **"The Evil's Den"**.

# Extracting the clues from description

The following is the challenge description that contains the needed clues to solve this lab.

> **A malicious script encrypted a very secret piece of information I had on my system. Can you recover the information for me please?**
> **Note-1: This challenge is composed of only 1 flag. The flag split into 2 parts**.
> **Note-2: You'll need the first half of the flag to get the second**.
> **You will need steghide to solve the challenge.**

I managed to extract the following two clues:
1. **A malicious script encrypted a very secret piece of information I had on my system**, is a hint to look for a script and understand it.
2. **You will need steghide to solve the challenge**, is a hint that there is data hidden in either image or audio file.

# Finding the image profile

First of all, we need to find the profile of the memory image using `imageinfo` plugin as in the following command.

> CommandLine 
{:.filename}
{% highlight CMD %}
$ ./vol -f MemoryDump_Lab3.raw imageinfo

Volatility Foundation Volatility Framework 2.6
INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86
                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)
                     AS Layer2 : FileAddressSpace (/home/oviche/Desktop/memlabs/MemoryDump_Lab3.raw)
                      PAE type : PAE
                           DTB : 0x185000L
                          KDBG : 0x82742c68L
          Number of Processors : 1
     Image Type (Service Pack) : 1
                KPCR for CPU 0 : 0x82743d00L
             KUSER_SHARED_DATA : 0xffdf0000L
           Image date and time : 2018-09-30 09:47:54 UTC+0000
     Image local date and time : 2018-09-30 15:17:54 +0530
{% endhighlight %}

The first suggested profile **"Win7SP1x86_23418"** worked in my case.

# Locating the malicious script

First, I looked at the running processes using `pslist`. I discovered two instances of the **notepad**, which are running as shown below.

![img]({{'/assets/images/MemLab3/img1.png' | relative_url }}){: .center-image }*(**The running processes**)*

So let's look over the command-line arguments of notepad processes using `cmdline` plugin.

> CommandLine 
{:.filename}
{% highlight CMD %}
$ ./vol -f MemoryDump_Lab3.raw cmdline | grep -i "notepad"

Volatility Foundation Volatility Framework 2.6
notepad.exe pid:   3736
Command line : "C:\Windows\system32\NOTEPAD.EXE" C:\Users\hello\Desktop\evilscript.py
notepad.exe pid:   3432
Command line : "C:\Windows\system32\NOTEPAD.EXE" C:\Users\hello\Desktop\vip.txt
{% endhighlight %}

In the above result from the `cmdline` command, the notepad instances open a Python script named **evilscript.py** and text file **vip.txt**.

Now we have found the malicious script, let's dump it to inspect the code.
> CommandLine 
{:.filename}
{% highlight CMD %}
$ ./vol -f MemoryDump_Lab3.raw --profile=Win7SP1x86_23418 filescan | grep -i "evilscript.py"

Volatility Foundation Volatility Framework 2.6
0x000000003de1b5f0      8      0 R--rw- \Device\HarddiskVolume2\Users\hello\Desktop\evilscript.py.py

$ ./vol -f MemoryDump_Lab3.raw --profile=Win7SP1x86_23418 dumpfiles -Q 0x000000003de1b5f0 -D DumpedFiles

Volatility Foundation Volatility Framework 2.6
DataSectionObject 0x3de1b5f0   None   \Device\HarddiskVolume2\Users\hello\Desktop\evilscript.py.py
{% endhighlight %}


> evilscript.py 
{:.filename}
{% highlight PYTHON %}
import sys
import string
def xor(s):
        a = ''.join(chr(ord(i)^3) for i in s)
        return a
def encoder(x):
        return x.encode("base64")
if __name__ == "__main__":
        f = open("C:\\Users\\hello\\Desktop\\vip.txt", "w")
        arr = sys.argv[1]
        arr = encoder(xor(arr))
        f.write(arr)
        f.close()
{% endhighlight %}



