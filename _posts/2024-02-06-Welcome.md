---
layout: post
title: "PwnableXYZ: Welcome challenge"
date: 2024-02-06
tags: [Pwn] 
description: This post discuss the solution for the first pwnable.xyz challenge.
---

# Introduction
That is my first post in 2024, so I thought to refresh my knowledge about binary exploitation by going through the [pwnable.xyz](https://pwnable.xyz/) challenges in my free time. This post will be the write-up for the first challenge **"Welcome"**.

# Gaining insights on the binary

The first step I usually do, is to check the mitigations of the binary using the `checksec` command in pwndbg. The command's output shows that all the mitigations are turned on.

![img]({{'/assets/images/PwnableXYZ-Welcome/img1.png' | relative_url }}){: .center-image }*(**The mitigations status**)*

By executing the binary, I found that it prints out a hexadecimal number representing a memory address leak and receives two inputs, which are the message's length and the message itself, as shown below.

> CommandLine 
{:.filename}
{% highlight CMD %}
$ ./challenge
Welcome.
Leak: 0x7f318f02c010
Length of your message: 5
Enter your message: aaaaa
aaaa
{% endhighlight %}

# Finding the vulnerability

The main function starts with calling the function at address 0x100b4e, which is responsible for stopping the buffering for stdin and stdout. Also, it automatically signals the program to exit in 60 seconds.

![img]({{'/assets/images/PwnableXYZ-Welcome/img2.png' | relative_url }}){: .center-image }*(**The function at 0x100b4e**)*

After that, it allocates memory from memory the heap whose address is saved to a pointer `HeapPtr1` and sets its first byte to 1. Then, it prints out the `HeapPtr1` value that represents the memory leak, we saw previously. In the next step, it receives from the user two inputs: a number representing the message size and the message. The message is a string whose address in the heap is saved into a pointer called `HeapPtr2`, as appears below.

![img]({{'/assets/images/PwnableXYZ-Welcome/img3.png' | relative_url }}){: .center-image }*(**Allocating memory for the message**)*

Finally, the last byte of the message is set to null, and the program prints it to the screen. Also, as appears below, to print the flag, the first byte of the memory pointed to by a `HeapPtr1` must be equal to zero. However, it's equal to one.

![img]({{'/assets/images/PwnableXYZ-Welcome/img4.png' | relative_url }}){: .center-image }*(**The vulnerable code**)*

The above highlighted line represents the vulnerability that will enable us to set the first byte of `HeapPtr1` to zero using the message size that we control.

# Exploiting the vulnerability










  
