---
layout: post
title: "PwnableXYZ: Welcome challenge"
date: 2024-02-06
tags: [Pwn] 
description: This post discuss the solution for the first pwnable.xyz challenge.
---

# Introduction
That is my first post in 2024, so I thought to refresh my knowledge about binary exploitation by going through the [pwnable.xyz](https://pwnable.xyz/) challenges in my free time. This post will be the write-up for the first challenge **"Welcome"**.

# Gaining insights on the binary

The first step I usually do, is to check the mitigations of the binary using the `checksec` command in pwndbg. The command's output shows that all the mitigations are turned on.

![img]({{'/assets/images/PwnableXYZ-Welcome/img1.png' | relative_url }}){: .center-image }*(**The mitigations status**)*

By executing the binary, I found that it prints out a hexadecimal number representing a memory address leak and receives two inputs, which are the message's length and the message itself, as shown below.

> CommandLine 
{:.filename}
{% highlight CMD %}
$ ./challenge
Welcome.
Leak: 0x7f318f02c010
Length of your message: 5
Enter your message: aaaaa
aaaa
{% endhighlight %}

# Finding the vulnerability

The main function starts with calling the function at address 0x100b4e, which is responsible for stopping the buffering for stdin and stdout. Also, it automatically signals the program to exit in 60 seconds.

![img]({{'/assets/images/PwnableXYZ-Welcome/img2.png' | relative_url }}){: .center-image }*(**The function at 0x100b4e**)*

After that, it allocates memory from memory the heap and sets its first byte to 1. Then, it outputs its address pointed to by `HeapPtr1`, as memory leakage, that we saw previously. In the next step, it receives from the user two inputs: a number representing the message size and the message. The message is a string whose address in the heap is saved into a pointer called `HeapPtr2`, as appears below.

![img]({{'/assets/images/PwnableXYZ-Welcome/img3.png' | relative_url }}){: .center-image }*(**The function at 0x100b4e**)*







  
